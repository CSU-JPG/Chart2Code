# This script reads image files specified in a JSON task file, uses the Qwen3-VL model
# to generate Python code based on each image, saves the result, and logs the process.
# It is designed to be executed via a shell script providing command-line arguments.
import os
import torch
from PIL import Image
from tqdm import tqdm
import re
import shutil
import csv
import argparse
import json
from transformers import AutoModelForCausalLM, AutoProcessor

# ===================================================================================
# Model Configuration
# ===================================================================================
# 1. Model ID from Hugging Face Hub (for 'hub' loading mode)
HUB_MODEL_ID = "Qwen/Qwen3-VL-30B-A3B-Instruct"

# 2. Path to the local model (for 'local' loading mode)
script_dir = os.path.dirname(os.path.abspath(__file__))
LOCAL_MODEL_PATH = os.path.abspath(os.path.join(script_dir, '..', '..', 'models', 'Qwen3-VL-30B-A3B-Instruct'))
# ===================================================================================

# --- Global Settings ---
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"

# --- Inference Parameters ---
INFERENCE_PARAMS = {
    "temperature": 0.1,
    "top_p": 0.9,
    "max_new_tokens": 32768,
    "do_sample": True
}

# --- Prompt Template ---
PROMPT_TEMPLATE = """You are a Python developer proficient in data visualization, with expertise in using libraries such as Matplotlib, NetworkX, Seaborn, and others.
I have a plot generated by Python code, but I don't have the corresponding code that generated this plot. Your task is to generate the Python code that can perfectly reproduce the picture based on the image I provide.

Here are the requirements for the task:
1. **Data Extraction**: Extract the actual data from the provided image. Based on the visual features of the plot, you must infer the data and recreate the plot.
2. **Recreate the Image**: Generate the Matplotlib code that reproduces the image exactly as it appears, including all elements such as:
   - Plot type (scatter, line, bar, etc.)
   - Axis labels and titles
   - Colors, markers, line styles, and other visual styles
   - Any legends, annotations, or gridlines present in the image
3. **Self-contained Code**: The Python code should be complete, executable, and self-contained. It should not require any external data files or variables not already present in the code.   
Your objective is to extract the any necessary details from the image and generate a Python script that accurately reproduces the plot. 

Now, please generate the Python code to reproduce the picture below.
The output format MUST be STRICTLY as follows:

```python
# Your Python code here to reproduce the image. IMPORTANT: THIS CODE BLOCK MUST START WITH ```python AND END WITH ``` AND ONLY CONTAIN THE CODE.
"""

# --- Helper Functions ---
def extract_python_code(raw_text: str) -> str:
    """Extracts Python code from a markdown-formatted string."""
    match = re.search(r"```python\s*\n(.*?)\n```", raw_text, re.DOTALL)
    if match:
        return match.group(1).strip()
    # Fallback for code blocks without the 'python' language identifier
    match = re.search(r"```\s*\n(.*?)\n```", raw_text, re.DOTALL)
    if match:
        return match.group(1).strip()
    return ""

def generate_code(image_path: str, model, processor) -> str:
    """Generates code for a given image using the Qwen-VL model."""
    try:
        messages = [
            {
                "role": "user",
                "content": [
                    {"type": "image"},
                    {"type": "text", "text": PROMPT_TEMPLATE},
                ],
            }
        ]
        
        # Load the image
        try:
            image = Image.open(image_path)
        except Exception as e:
            tqdm.write(f"   - Error: Could not open image file {os.path.basename(image_path)}: {e}")
            return None

        text = processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)
        inputs = processor(text, [image], return_tensors="pt").to(model.device)
        
        with torch.no_grad():
            generated_ids = model.generate(**inputs, **INFERENCE_PARAMS)
        
        generated_ids_trimmed = generated_ids[:, inputs['input_ids'].shape[1]:]
        response = processor.batch_decode(generated_ids_trimmed, skip_special_tokens=True)[0]
        
        return response.strip()

    except Exception as e:
        tqdm.write(f"   - Error: Exception in inference function -> Task: {os.path.basename(image_path)} | Error: {e}")
        return None

# --- Main Batch Processing ---
def main():
    # 1. Argument Parsing
    parser = argparse.ArgumentParser(description="Generate Python code from JSON tasks using Qwen-VL.")
    parser.add_argument("--load_source", type=str, required=True, choices=['hub', 'local'], help="Where to load the model from.")
    parser.add_argument("--json_path", type=str, required=True, help="Path to the input JSON file containing tasks.")
    parser.add_argument("--output_dir", type=str, required=True, help="Directory to save the generated Python code.")
    parser.add_argument("--log_path", type=str, required=True, help="Path to save the output CSV log file.")
    args = parser.parse_args()

    # 2. Setup Output Directories
    GENERATED_CODE_DIR = args.output_dir
    FAILED_FILES_DIR = f"{GENERATED_CODE_DIR}_failed"
    LOG_CSV_PATH = args.log_path

    os.makedirs(GENERATED_CODE_DIR, exist_ok=True)
    os.makedirs(FAILED_FILES_DIR, exist_ok=True)
    os.makedirs(os.path.dirname(LOG_CSV_PATH), exist_ok=True)

    # 3. Determine Model Path
    if args.load_source == 'local':
        model_to_load = LOCAL_MODEL_PATH
        print(f"Mode: Loading model from local path: {model_to_load}")
        if not os.path.isdir(model_to_load):
            print(f"❌ Error: Local model path not found. Please check the path in the script.")
            exit(1)
    else: # 'hub'
        model_to_load = HUB_MODEL_ID
        print(f"Mode: Loading model from Hugging Face Hub: {model_to_load}")

    # 4. Load Model and Processor
    print(f"Current device: {DEVICE}")
    try:
        processor = AutoProcessor.from_pretrained(model_to_load, trust_remote_code=True)
        model = AutoModelForCausalLM.from_pretrained(
            model_to_load, 
            torch_dtype=torch.float16, 
            device_map="auto",
            trust_remote_code=True
        ).eval()
        print("✅ Qwen-VL model and processor loaded successfully!")
    except Exception as e:
        print(f"❌ Model loading failed: {e}")
        exit()

    # 5. Load and Prepare Task Data from JSON
    try:
        with open(args.json_path, 'r', encoding='utf-8') as f:
            tasks = json.load(f)
    except Exception as e:
        print(f"❌ Error reading or parsing JSON file '{args.json_path}': {e}")
        return

    print("Cleaning JSON keys...")
    cleaned_tasks = [{key.strip(): value for key, value in task_dict.items()} for task_dict in tasks]
    tasks = cleaned_tasks
    data_root = os.path.dirname(args.json_path)
    print(f"Found {len(tasks)} tasks to process from JSON...")

    # 6. Batch Process Tasks
    processed_count = 0
    failure_count = 0

    try:
        with open(LOG_CSV_PATH, 'w', newline='', encoding='utf-8') as csvfile:
            csv_writer = csv.writer(csvfile)
            # Use a consistent header, marking non-applicable fields as N/A during logging
            csv_writer.writerow(["Task ID", "Status", "Instruction Text", "Data String", "Raw Model Output", "Extracted Code"])

            for task in tqdm(tasks, desc="Processing tasks"):
                task_id = task.get("task_id", f"unknown_task_{processed_count + failure_count}")

                # Get relative paths from the JSON task
                relative_image_path = task.get("input image")
                gt_image_path = task.get("GT image") # Used for naming the output file

                # Validate that all required paths exist
                if not all([relative_image_path, gt_image_path]):
                    tqdm.write(f"   - Warning: Skipping task '{task_id}' due to missing 'input image' or 'GT image' keys.")
                    csv_writer.writerow([task_id, "FAILURE_MISSING_PATHS", "N/A", "N/A", "N/A", "N/A"])
                    failure_count += 1
                    continue

                # Construct full file paths
                image_path = os.path.join(data_root, relative_image_path)
                
                # Create the output filename based on the GT image filename
                base_filename = os.path.basename(gt_image_path)
                filename_root, _ = os.path.splitext(base_filename)
                output_path = os.path.join(GENERATED_CODE_DIR, f"{filename_root}.py")

                if os.path.exists(output_path):
                    tqdm.write(f"   - Skipping: Output file already exists '{output_path}'")
                    csv_writer.writerow([task_id, "SKIPPED_EXISTS", "N/A", "N/A", "N/A", "N/A"])
                    continue

                # Run inference
                raw_generated_text = generate_code(image_path, model, processor)

                if raw_generated_text:
                    clean_code = extract_python_code(raw_generated_text)
                    with open(output_path, 'w', encoding='utf-8') as f:
                        f.write(clean_code)
                    # Log success, using PROMPT_TEMPLATE for instruction and N/A for data string
                    csv_writer.writerow([task_id, "SUCCESS", PROMPT_TEMPLATE, "N/A", raw_generated_text, clean_code])
                    processed_count += 1
                else:
                    failure_count += 1
                    tqdm.write(f"   - Failure: Inference failed for task '{task_id}'")
                    # Log failure
                    csv_writer.writerow([task_id, "FAILURE_INFERENCE", PROMPT_TEMPLATE, "N/A", "N/A", "N/A"])
                    try:
                        shutil.copy(image_path, FAILED_FILES_DIR)
                    except Exception as e:
                        tqdm.write(f"   - Critical Error: Failed to copy failure file for '{task_id}': {e}")

    except IOError as e:
        print(f"❌ Critical Error: Could not write to CSV log file '{LOG_CSV_PATH}'. Error: {e}")
    finally:
        print(f"\n--- ✅ Batch Processing Complete ---")
        print(f"Log saved to: {LOG_CSV_PATH}")
        print(f"Success: {processed_count} | Failed: {failure_count}")

if __name__ == "__main__":
    main()

