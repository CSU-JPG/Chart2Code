# This script reads a JSON file to get image paths, generates Python code for the images using a predefined prompt template and the Qwen2.5-VL-72B-Instruct model,
# and saves the results to a specified directory while logging the process.
# It can be configured via command-line arguments.

import os
import torch
from PIL import Image
from tqdm import tqdm
import re
import shutil
import csv
from transformers import Qwen2_5_VLForConditionalGeneration, AutoProcessor
import argparse
import json

# This utility function is specific to the Qwen-VL models and is required for processing visual inputs.
# Please ensure the 'qwen_vl_utils.py' file is in the same directory as this script.
from qwen_vl_utils import process_vision_info


# ===================================================================================
# Model Configuration (Modify here)
# ===================================================================================
# 1. Model ID on Hugging Face Hub (for online loading)
HUB_MODEL_ID = "Qwen/Qwen2.5-VL-72B-Instruct"

# 2. Path to the local model (relative to this .py file)
#    This script is assumed to be in a directory like .../Inference/level1_direct/models/
#    This path goes up to find the .../Inference/models/ folder
script_dir = os.path.dirname(os.path.abspath(__file__))
# Example: Go back from .../Inference/level1_direct/models/ to .../Inference/ and then into models/
LOCAL_MODEL_PATH = os.path.abspath(os.path.join(script_dir, '..', '..', 'models', 'Qwen2.5-VL-72B-Instruct'))
# ===================================================================================


# --- Global Variables ---
# processor and model will be loaded in the main function based on arguments
processor = None
model = None

# --- New Prompt Template (Do not change) ---
PROMPT_TEMPLATE = """You are a Python developer proficient in data visualization, with expertise in using libraries such as Matplotlib, NetworkX, Seaborn, and others.I have a plot generated by Python code, but I don't have the corresponding code that generated this plot. Your task is to generate the Python code that can perfectly reproduce the picture based on the image I provide.

Here are the requirements for the task:
1. **Data Extraction**: Extract the actual data from the provided image. Based on the visual features of the plot, you must infer the data and recreate the plot.
2. **Recreate the Image**: Generate the Matplotlib code that reproduces the image exactly as it appears, including all elements such as:
   - Plot type (scatter, line, bar, etc.)
   - Axis labels and titles
   - Colors, markers, line styles, and other visual styles
   - Any legends, annotations, or gridlines present in the image
3. **Self-contained Code**: The Python code should be complete, executable, and self-contained. It should not require any external data files or variables not already present in the code.
Your objective is to extract the any necessary details from the image and generate a Python script that accurately reproduces the plot.

Now, please generate the Python code to reproduce the picture below.
The output format must be strictly as follows:

```python
# Your Python code here to reproduce the image.
"""

# --- Inference Parameters (Do not change) ---
INFERENCE_PARAMS = {
    "temperature": 0.1,
    "top_p": 0.9,
    "max_new_tokens": 4096,  # Can be adjusted as needed
    "do_sample": True
}


# --- Code Extraction Function (Do not change) ---
def extract_python_code(raw_text: str) -> str:
    """
    Extracts Python code from a markdown-formatted string.
    Returns an empty string if no code block is found.
    """
    match = re.search(r"```python\s*\n(.*?)\n```", raw_text, re.DOTALL)
    if match:
        return match.group(1).strip()
    
    match = re.search(r"```\s*\n(.*?)\n```", raw_text, re.DOTALL)
    if match:
        return match.group(1).strip()
        
    return ""

# --- Core Inference Function (Do not change) ---
def generate_code_for_image(image_path: str) -> str:
    """Generates code for a given image using the global prompt template."""
    try:
        messages = [
            {
                "role": "user",
                "content": [
                    {"type": "image", "image": image_path},
                    {"type": "text", "text": PROMPT_TEMPLATE},
                ],
            }
        ]
        
        text_prompt = processor.apply_chat_template(
            messages, tokenize=False, add_generation_prompt=True
        )
        image_inputs, video_inputs = process_vision_info(messages)

        inputs = processor(
            text=[text_prompt],
            images=image_inputs,
            videos=video_inputs,
            return_tensors="pt",
        ).to(model.device)
        
        with torch.no_grad():
            generated_ids = model.generate(
                **inputs, 
                **INFERENCE_PARAMS,
                pad_token_id=processor.tokenizer.pad_token_id
            )
            
        generated_ids_trimmed = [out_ids[len(in_ids):] for in_ids, out_ids in zip(inputs.input_ids, generated_ids)]
        response = processor.batch_decode(generated_ids_trimmed, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]
        
        return response.strip()
    
    except Exception as e:
        tqdm.write(f"   - Error: Exception caught inside the inference function -> {os.path.basename(image_path)} | Error: {e}")
        return None

# --- Batch Processing Main Flow ---
def main():
    # --- Added: More flexible command-line argument parsing ---
    parser = argparse.ArgumentParser(description="Generate Python code for images specified in a JSON file using the Qwen2.5-VL-72B-Instruct model.")
    # Add --load_source argument to select the model source
    parser.add_argument('--load_source', type=str, choices=['local', 'hub'], default='hub', 
                        help="Select model loading source: 'local' (from a local path) or 'hub' (download from Hugging Face Hub).")
    parser.add_argument('--json_path', type=str, required=True, help="Path to the input JSON file containing image paths.")
    parser.add_argument('--output_dir', type=str, required=True, help="Directory to save the generated Python code.")
    parser.add_argument('--log_path', type=str, required=True, help="Path to save the CSV log file.")
    args = parser.parse_args()

    # --- Determine which model to load based on the --load_source argument ---
    if args.load_source == 'hub':
        model_to_load = HUB_MODEL_ID
        print("Mode: Loading model from Hugging Face Hub.")
    else: # 'local'
        model_to_load = LOCAL_MODEL_PATH
        print("Mode: Loading model from local path.")
        # Add a check for the local path
        if not os.path.isdir(model_to_load):
            print(f"❌ Error: Local model path not found: '{model_to_load}'")
            print("Please check if the LOCAL_MODEL_PATH variable at the top of the file is configured correctly, or confirm that the model files exist.")
            exit(1)

    # --- Model Loading ---
    global processor, model
    print(f"Loading Qwen2.5-VL-72B-Instruct model and processor from '{model_to_load}'...")
    try:
        processor = AutoProcessor.from_pretrained(model_to_load, trust_remote_code=True, max_pixels=1280 * 28 * 28)
        model = Qwen2_5_VLForConditionalGeneration.from_pretrained(
            model_to_load,
            torch_dtype=torch.float16,
            low_cpu_mem_usage=True,
            device_map="balanced", # Use "balanced" for multi-GPU as in the original script
            trust_remote_code=True
        ).eval()

        # Robustness improvement: Ensure pad_token is set to avoid generation errors
        if processor.tokenizer.pad_token_id is None:
            processor.tokenizer.pad_token_id = processor.tokenizer.eos_token_id

        print("✅ Model and processor loaded successfully!")
    except Exception as e:
        print(f"❌ Model loading failed: {e}")
        exit()

    # --- Configure paths from command-line arguments ---
    JSON_FILE_PATH = args.json_path
    GENERATED_CODE_DIR = args.output_dir
    LOG_CSV_PATH = args.log_path
    FAILED_FILES_DIR = f"{GENERATED_CODE_DIR}_failed"

    os.makedirs(GENERATED_CODE_DIR, exist_ok=True)
    os.makedirs(FAILED_FILES_DIR, exist_ok=True)

    # --- Read image list from JSON file ---
    try:
        with open(JSON_FILE_PATH, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # Key point: The calculation logic for data_dir remains unchanged because it relies on the script's actual location to find the project root directory.
        script_dir = os.path.dirname(os.path.abspath(__file__))
        # Here, it's assumed the script is in a three-level subdirectory, e.g., benchmark/Inference/level1_direct/models/
        data_dir = os.path.abspath(os.path.join(script_dir, '..', '..', '..', 'data'))
        
        image_files = []
        for item in data:
            if "input image" in item and item["input image"]:
                relative_path = item["input image"]
                full_path = os.path.join(data_dir, relative_path)
                image_files.append(full_path)
    except FileNotFoundError:
        print(f"❌ Error: JSON file not found -> '{JSON_FILE_PATH}'")
        return
    except json.JSONDecodeError:
        print(f"❌ Error: Could not parse JSON file -> '{JSON_FILE_PATH}'")
        return
    except Exception as e:
        print(f"❌ Error: An unknown error occurred while reading the JSON file: {e}")
        return

    if not image_files:
        print(f"❌ Error: No valid 'input image' entries found in the JSON file '{JSON_FILE_PATH}'.")
        return

    total_files = len(image_files)
    print(f"Found {total_files} images in '{os.path.basename(JSON_FILE_PATH)}', starting processing...")

    success_count = 0
    failure_count = 0

    try:
        with open(LOG_CSV_PATH, 'w', newline='', encoding='utf-8') as csvfile:
            csv_writer = csv.writer(csvfile)
            csv_writer.writerow(["Figure Filename", "Status", "Instruction", "Raw Model Output", "Extracted Code"])

            for image_path in tqdm(image_files, desc="Processing progress"):
                if not os.path.exists(image_path):
                    tqdm.write(f"   - Warning: Image file not found, skipping -> {image_path}")
                    csv_writer.writerow([os.path.basename(image_path), "SKIPPED_NOT_FOUND", "N/A", "N/A", "N/A"])
                    continue
                
                base_name, _ = os.path.splitext(os.path.basename(image_path))
                output_path = os.path.join(GENERATED_CODE_DIR, f"{base_name}.py")
                figure_filename = os.path.basename(image_path)

                if os.path.exists(output_path):
                    tqdm.write(f"   - Skipping: Output file '{output_path}' already exists")
                    csv_writer.writerow([figure_filename, "SKIPPED_EXISTS", PROMPT_TEMPLATE, "N/A", "N/A"])
                    continue

                raw_generated_text = generate_code_for_image(image_path)
                
                if raw_generated_text:
                    clean_code = extract_python_code(raw_generated_text)
                    
                    if clean_code:
                        with open(output_path, 'w', encoding='utf-8') as f:
                            f.write(clean_code)
                        csv_writer.writerow([figure_filename, "SUCCESS", PROMPT_TEMPLATE, raw_generated_text, clean_code])
                        success_count += 1
                    else:
                        failure_count += 1
                        tqdm.write(f"   - Failure: Failed to extract valid code from model output -> {base_name}")
                        csv_writer.writerow([figure_filename, "FAILURE_EXTRACT", PROMPT_TEMPLATE, raw_generated_text, ""])
                        shutil.copy(image_path, FAILED_FILES_DIR)
                else:
                    failure_count += 1
                    tqdm.write(f"   - Failure: Error occurred during inference -> {base_name}")
                    csv_writer.writerow([figure_filename, "FAILURE_INFERENCE", PROMPT_TEMPLATE, "N/A", "N/A"])
                    try:
                        shutil.copy(image_path, FAILED_FILES_DIR)
                    except Exception as e:
                        tqdm.write(f"   - Critical Error: An error also occurred while copying the failed file: {e}")

    except IOError as e:
        print(f"❌ Critical Error: Could not write to CSV log file '{LOG_CSV_PATH}'. Error: {e}")
    finally:
        print(f"\n--- ✅ Batch processing complete (Model: Qwen2.5-VL-72B-Instruct) ---")
        print(f"Detailed log saved to: {LOG_CSV_PATH}")
        print(f"Successfully processed: {success_count} | Failed: {failure_count}")

if __name__ == "__main__":
    main()

